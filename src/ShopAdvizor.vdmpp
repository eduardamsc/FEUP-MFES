class ShopAdvizor
types
	public String = seq1 of char;

values

instance variables
	public m_products: set of Product;
	public m_users: set of User;
	public m_retailers: set of Retailer;
	public m_brands: set of Brand;
	public m_activities: set of Activity;
	
	inv forall b1, b2 in set m_brands & b1 <> b2 => b1.m_name <> b2.m_name;
	inv forall r1, r2 in set m_retailers & r1 <> r2 => r1.m_name <> r2.m_name;
	inv forall u1, u2 in set m_users & u1 <> u2 => u1.m_username <> u2.m_username;
	inv forall p1, p2 in set m_products & p1 <> p2 => p1.m_name <> p2.m_name or p1.m_brand <> p2.m_brand;
	inv forall a1, a2 in set m_activities & a1 <> a2 => a1.m_title <> a2.m_title;
	
operations
	-- ShopAdvizor constructor
	public ShopAdvizor : () ==> ShopAdvizor
	ShopAdvizor() ==
	(
		m_products := {};
		m_users := {};
		m_retailers := {};
		m_brands := {};
		m_activities := {};
		return self;
	);
	
	-- Get brand by name
	public getBrand : String ==> [Brand]
	getBrand(name) == 
	(	
		dcl brand : Brand;
		if exists1 b in set m_brands & b.m_name = name
		then (
			brand := iota b in set m_brands & b.m_name = name;
			return brand;
		)
		else return nil;
	);
	
	-- Get user by name
	public getUser : String ==> [User]
	getUser(name) == 
	(	
		dcl user : User;
		if exists1 u in set m_users & u.m_username = name
		then (
			user := iota u in set m_users & u.m_username = name;
			return user;
		)
		else return nil;
	);	
	
	-- Get activity by title
	public getActivity : String ==> [Activity]
	getActivity(title) == 
	(	
		dcl activity : Activity;
		if exists1 a in set m_activities & a.m_title = title
		then (
			activity := iota a in set m_activities & a.m_title = title;
			return activity;
		)
		else return nil;
	);
	
	-- Get product by name and brand
	public getProduct : String * Brand ==> [Product]
	getProduct(name, brand) == 
	(	
		dcl product : Product;
		if exists1 p in set m_products & p.m_name = name and p.m_brand = brand
		then (
			product := iota p in set m_products & p.m_name = name and p.m_brand = brand;
			return product;
		)
		else return nil;
	);
	
	-- Gets all reviews of a product
	public getProductReviews : String * String ==> [map User to Product`Review]
	getProductReviews(product_name, brand_name) == 
	(	
		dcl brand : [Brand] := getBrand(brand_name);
		dcl product : [Product];
		if brand = nil then return nil;
		product := getProduct(product_name, brand);
		if product = nil then return nil
		else return product.m_reviews
	);
	
	-- Gets all reviews given by a user
	public getUserReviews : String ==> [set of (Product * Product`Review)]
	getUserReviews(username) == 
	(	
		dcl user : [User] := getUser(username);
		dcl reviews : set of (Product * Product`Review);
		if user = nil
			then return nil
		else (
			reviews := dunion { { mk_(r, r.m_reviews(user)) | u in set dom r.m_reviews & u = user} | r in set m_products};
			return reviews;
		)
	);
	
	-- Gets the retailer with the lowest price on a product
	public getLowestPriceRetailer : Product ==> [Retailer * rat]
	getLowestPriceRetailer(product) == 
	(	
		dcl retailer : Retailer * rat; -- Retailer that sells for the lowest price
		dcl retailers : set of (Retailer * rat); -- Retailers that sell the product
		if product not in set m_products
			then return nil
		else (
			retailers := { mk_(r, r.m_items(product).price) | r in set m_retailers & product in set dom r.m_items };
			if exists r1 in set retailers & (forall r2 in set retailers & r1.#2 <= r2.#2)
				then (
					retailer := iota r1 in set retailers & (forall r2 in set retailers & r1.#2 <= r2.#2);
					return retailer;
				)
			else return nil;
		)
	);
	
	--Adds a product to products set
	public insertProduct : Product ==> ()
	insertProduct(product) ==
	(
		m_products := m_products union {product}
	)
	pre product not in set m_products and product.m_brand in set m_brands
	post m_products = m_products~ union {product};
	
	--Adds a user to users set
	public insertUser : User ==> ()
	insertUser(user) ==
	(
		m_users := m_users union {user}
	)
	pre user not in set m_users
	post m_users = m_users~ union {user};
	
	--Adds a retailer to retailers set
	public insertRetailer : Retailer ==> ()
	insertRetailer(retailer) ==
	(
		m_retailers := m_retailers union {retailer}
	)
	pre retailer not in set m_retailers
	post m_retailers = m_retailers~ union {retailer};
	
	--Adds an activity to activities set
	public insertActivity : Activity ==> ()
	insertActivity(activity) ==
	(
		m_activities := m_activities union {activity}
	)
	pre activity not in set m_activities
	post m_activities = m_activities~ union {activity};
	
	--Adds a brand to brands set
	public insertBrand : Brand ==> ()
	insertBrand(brand) ==
	(
		m_brands := m_brands union {brand}
	)
	pre brand not in set m_brands
	post m_brands = m_brands~ union {brand};
	
	--Login
	public login : String * String ==> [User]
	login(username, password) == 
	(
		if exists1 u in set m_users & u.m_username = username and u.passwordMatches(password)
			then return iota u in set m_users & u.m_username = username and u.passwordMatches(password)
		else return nil;
	);
	
	-- Start activity
	public startActivity : String ==> ()
	startActivity(title) == 
	(	
		dcl activity : [Activity] := getActivity(title);
		if activity <> nil
			then activity.startActivity()
	);
	
	-- End activity
	public endActivity : String ==> ()
	endActivity(title) == 
	(	
		dcl activity : [Activity] := getActivity(title);
		if activity <> nil
			then activity.endActivity()
	);
	
	-- Add competitor to competition
	public addCompetitor : String * String ==> ()
	addCompetitor(title, username) == 
	(	
		dcl activity : [Competition] := getActivity(title);
		dcl user : [User] := getUser(username);
		if user <> nil and activity <> nil and isofclass(Competition, activity)
			then activity.addCompetitor(user)
	);
	
	-- Choose winner of a competition
	public chooseWinner : String * String ==> ()
	chooseWinner(title, username) == 
	(	
		dcl activity : [Competition] := getActivity(title);
		dcl user : [User] := getUser(username);
		if user <> nil and activity <> nil and isofclass(Competition, activity)
			then activity.chooseWinner(user)
	);
	
functions

traces

end ShopAdvizor