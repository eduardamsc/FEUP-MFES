class ShopAdvizor
types
	public Products = set of Product;
	public Users = set of User;
	public Retailers = set of Retailer;
	public Brands = set of Brand;
	public Substances = set of Substance;
		
values
-- TODO Define values here

instance variables
	public m_products: Products;
	public m_users: Users;
	public m_retailers: Retailers;
	public m_brands: Brands;
	public m_substances: Substances;
	
	inv forall b1, b2 in set m_brands & b1 <> b2 => b1.m_name <> b2.m_name;
	inv forall r1, r2 in set m_retailers & r1 <> r2 => r1.m_name <> r2.m_name;
	inv forall u1, u2 in set m_users & u1 <> u2 => u1.m_username <> u2.m_username;
	inv forall p1, p2 in set m_products & p1 <> p2 => p1.m_name <> p2.m_name or p1.m_brand <> p2.m_brand;
	
operations
	-- ShopAdvizor constructor
	public ShopAdvizor :  Products * Users * Retailers * Brands * Substances ==> ShopAdvizor
	ShopAdvizor(products, users, retailers, brands, substances) ==
	(
		m_products := products;
		m_users := users;
		m_retailers := retailers;
		m_brands := brands;
		m_substances := substances;
		return self;
	);
	
	-- ShopAdvizor constructor with no arguments
	public ShopAdvizor : () ==> ShopAdvizor
	ShopAdvizor() ==
	(
		m_products := {};
		m_users := {};
		m_retailers := {};
		m_brands := {};
		m_substances := {};
		return self;
	);
	
	-- Returns all products
	public getProducts : ()  ==> Products
	getProducts() == return m_products;
	
	-- Returns all users
	public getUsers : ()  ==> Users
	getUsers() == return m_users;
	
	-- Returns all retailers
	public getRetailers : ()  ==> Retailers
	getRetailers() == return m_retailers;
	
	-- Returns all brands
	public getBrands : ()  ==> Brands
	getBrands() == return m_brands;
	
	-- Returns all substances
	public getSubstances : ()  ==> Substances
	getSubstances() == return m_substances;
	
	-- Get brand by name
	public getBrand : seq1 of char ==> [Brand]
	getBrand(name) == 
	(	
		dcl brand : Brand;
		if exists1 b in set m_brands & b.m_name = name
		then (
			brand := iota b in set m_brands & b.m_name = name;
			return brand;
		)
		else return nil;
	);	
	
	-- Get user by name
	public getUser : seq1 of char ==> [User]
	getUser(name) == 
	(	
		dcl user : User;
		if exists1 u in set m_users & u.m_username = name
		then (
			user := iota u in set m_users & u.m_username = name;
			return user;
		)
		else return nil;
	);	
	
	-- Get product by name and brand
	public getProduct : seq1 of char * Brand ==> [Product]
	getProduct(name, brand) == 
	(	
		dcl product : Product;
		if exists1 p in set m_products & p.m_name = name and p.m_brand = brand
		then (
			product := iota p in set m_products & p.m_name = name and p.m_brand = brand;
			return product;
		)
		else return nil;
	);
	
	-- Gets all reviews of a product
	public getProductReviews : seq1 of char * seq1 of char ==> [set of Product`Review]
	getProductReviews(product_name, brand_name) == 
	(	
		dcl brand : [Brand] := getBrand(brand_name);
		dcl product : [Product] := getProduct(product_name, brand);
		if brand = nil or product = nil
			then return nil
		else return product.getReviews()
	);
	
	-- Gets all reviews given by a user
	public getUserReviews : seq1 of char ==> [set of (Product * Product`Review)]
	getUserReviews(username) == 
	(	
		dcl user : [User] := getUser(username);
		dcl reviews : set of (Product * Product`Review);
		if user = nil
			then return nil
		else (
			reviews := dunion { { mk_(r, r.m_reviews(user)) | u in set dom r.m_reviews & u = user} | r in set m_products};
			return reviews;
		)
	);
	
	--Adds a product to products set
	public insertProduct : Product ==> ()
	insertProduct(product) ==
	(
		m_products := m_products union {product}
	)
	pre product not in set m_products
	post m_products = m_products~ union {product};
	
	--Adds a user to users set
	public insertUser : User ==> ()
	insertUser(user) ==
	(
		m_users := m_users union {user}
	)
	pre user not in set m_users
	post m_users = m_users~ union {user};
	
	--Adds a retailer to retailers set
	public insertRetailer : Retailer ==> ()
	insertRetailer(retailer) ==
	(
		m_retailers := m_retailers union {retailer}
	)
	pre retailer not in set m_retailers
	post m_retailers = m_retailers~ union {retailer};
	
	--Adds a brand to brands set
	public insertBrand : Brand ==> ()
	insertBrand(brand) ==
	(
		m_brands := m_brands union {brand}
	)
	pre brand not in set m_brands
	post m_brands = m_brands~ union {brand};
	
	--Adds a substance to substances set
	public insertSubstance : Substance ==> ()
	insertSubstance(substance) ==
	(
		m_substances := m_substances union {substance}
	)
	pre substance not in set m_substances
	post m_substances = m_substances~ union {substance};
	
functions
	-- Get brand by name
	/*public getByName[@T] : seq1 of char * set of @T -> [@T]
	getByName(name, vec) == 
	(	
		if exists1 e in set vec & e.m_name = name
		then (
			return iota e in set vec & e.m_name = name;
		)
		else return nil;
	);*/
traces
-- TODO Define Combinatorial Test Traces here

end ShopAdvizor